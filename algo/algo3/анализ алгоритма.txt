Анализ.
Функция append (для разминки).

Асимптотический анализ.
Пока объём массива не превышает ёмкость массива, добавление элемента стоит O(1). Как только объём и ёмкость сравняются,
требуется создавать новый массив и переносить в него все элемента. Цена такой операции - O(n).

Анализ мультипликативной схемы с помощью банковского метода.
Назначим цену добавления одного элемента - 3 (реальная - 1). Мы создали массив, добавили 16 значений, на балансе (3-1)*16 = 32.
Добавление 17-го элемента потребует реаллокации. Включая добавление последнего, реальная стоимость реаллокации составит 17. 
На балансе будет 32 + 3 (цена добавления одного элемента) - 17 (реальная цена добавления) = 18.
Объём массива составляет 17, ёмкость - 32. Следующие 15 вызовов добавят на баланс (3-1)*15 = 30. На балансе - 48.
Добавление 33-го элемента снова потребует реаллокации. Реальная стоимость составит 33.
На балансе будет 48 + 3 - 33 = 18. Снова 18. Снова на балансе ёмкость + 2. Такой подход позволяет оценить цену операции в O(1),
независимо от того, происходит реаллокация, или нет, т.к. баланс всегда положительный. Остаётся только решить, устраивает ли
нас условная цена добавления одного элемента в 3 операции.

Функция insert.

Асимптотический анализ. 
Пока объём массива не превышает ёмкость массива, вставка элемента происходит с помощью сдвигания элементов массива на 1, начиная
с конца массива, до достижения i, куда и вставляется указанны элемент. В идеальной ситуации, элемент добавляется в конец, цена - 
1 операция. В наихудшей - в начало, цена - n. Следовательно, вставка элемента без реаллокации - O(n).
В случае реаллокации придётся создать новый массив и переместить туда все элементы до i-го, потом добавить новый элемент, и далее
перемещать элементы с i+1-го. Таким образом, в случае реаллокации, любая ситуация (и наилучшая, и наихудшая) даёт нам O(n).

Анализ мультипликативной схемы с помощью банковского метода.
Назначим цену добавления одного элемента - 3 (реальная - 1). 
В случае вставки в конец массива, ситуация вырождает в предыдущую (append).
Не представляю, как оценить ситуацию, когда в неполностью заполненный (15 из 16) массив вставляют 1 элемент. Все ситуации слишком
индивидуальны. Допустим, до сей поры массив заполняли с помощью append, на балансе (3-1)*15 = 30. Вставляем на 14-ю позицию.
Скопировать 15 на 16, скопировать 14 на 15, поместить на 14 новый элемент (реальная цена - 3). До реаллокации баланс не изменился.
Вставляем на 1 позицию. 15 на 16, 14 на 15, ..., 1 на 2, поместить на 1 новый элемент (реальная цена - 16). На балансе осталось 14.
Если при наихудшей ситуации вставить ещё 1 элемент, то попадаем ещё и на реаллокацию: придётся перенести все 16 элементов в новый
массив с добавлением в процессе 17-го, а это 14-17 = -3 на балансе. Значит в данной ситуации метод не подходит? Или я неправильно 
им воспользовался?

Функцию delete разберу позже, когда пойму, где я накосячил в анализе insert.

Заодно попробовал разобрать асимптотически решение задачи из предыдущего курса. И результат меня огорчил.
При решении задачи 3 из курса 1.3 примем упрощение N=M (в дальнейшем будем обозначать эти величины символом n).
Добавление элемента в список занимает O(1).
В функции ConquestCampaign на инициализацию массива country уходит O(1)+O(n)+O(1) ~= O(n)
На заполнение точек высадки десанта - O(L). По условию задачи L < n => O(n)+O(L) ~= O(n)

Далее в цикле while совершает проход по массиву координат с целью инкремента всех ненулевых значений. Этот проход стоит O(n^2).
Далее происходит ещё один проход по тому же массиву, при этом отягощенный большим количеством условных операторов. Этот проход стоит O(n^2+k*n) ~= O(n^2).
В условии while содержится проверка наличия нуля хотя бы в одной ячейке массива. В худшем случае это O(n^2).

Т.е. n раз происходит 3*O(n^2) => сложность алгоритма по времени ~= O(n^3). Требуется оптимизация.
Сложность алгоритма по памяти равна O(n^2), дальнейшая оптимизация невозможна, и так не создаётся лишних структур.

