Запоздалый анализ стека.
Операция push.
С точки зрения асимптотического анализа, добавление элемента в стек требует следующего набора операций:
 - взять последний элемент стека (если стек не пустой)
 - записать новый элемент в качестве следующего (или записать его в качестве первого, в случае пустого стека)
 - обозначить новый элемент последним
 - повысить счётчик
4 операции дают нам O(4), что эквивалентно O(1).
Операция enqueue в очереди реализована идентично, что даёт возможность утверждать, что её сложность так же О(1).

Такие же рассуждения касаются операция pop и dequeu. Их сложность так же равна O(1).

Если построить хранение значений с использованием переменной класса list (динамического массива по своей сути), то
из-за появления необходимости реаллокации сложность этих операций вырастает до О(1), что подтверждает правильность
выбора построения стека и очереди на основе двунаправленного связного списка.

Амортизационный анализ в ситуации с операциями push и pop, а также enqueue и dequeue мне кажется избыточным, т.к.
и операции добавления, и операции извлечения и так стоят О(1). Но если попытаться всё же вычислить, то:
1) потенциал push =  1 + i - (i-1) = 2. Столько же равен потенциал enqueu.
2) потенциал pop = 1 + (i-1) - i = 0. Столько равен потенциал dequeu.
3) потенциал извлечения n элементов (при условии, что размер стека/очереди равен n) = 1*n + (i-1)*n - i*n =
n + n*i - n - n*i = 0. Суть волшебства, как мне кажется, в том, что по мере наполнения стека/очереди n
повторений операции push/enqueue накопили 2*n "потенциальной энергии", которая потом была потрачена на извлечение всех
элементов из стека/очереди
