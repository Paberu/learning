# Второе прохождение курса

Прохождение второе, но решение всё равно кажется рабочим и свежим:

Если хочется собрать простой рабочий прототип, то задать все возможные элементы поля можно самым обычным перечислением:
```Python
elements = Enum('A', 'B', 'C', 'D', 'E', 'F')
```
Если же для каждого типа элемента планируется уникальное поведение на появление или уничтожение или некая анимация после добавления в проект GUI-модуля, то оптимальнее становится задание некой абстракции Element, возможно, воплощённой в виде абстрактного класса:
```Python
from abc import ABC, abstractmethod
class Element(ABC):
	
	def __init__(self, sprite):
		self.sprite = sprite
		
	@abstractmethod
	def behaviour_on_appearence(self):
		pass
		
	@abstractmethod
	def behaviour_on_delete(self):
		pass

```
Так становится возможным создавать элементы, которые появляются не при заполнении поля, а при схлопывании элементов в комбинации (бомбы, молнии и прочие бонусы, ставшие каноничными в такого рода играх).

Для таких ситуаций необходимо проверять некий количественный параметр совпадения: можно собрать 3, 4 или 5 элементов в линию, можно собрать Г-образную комбинацию из 5 элементов, или Т-образную комбинацию из 5, 6 или 7 элементов. Соответственно, появляется необходимость в проверке: есть ли общие элементы у каждого вертикального с каждым горизонтальным элементом. Можно обойтись чисто функциональным стилем:
- matches - это не массив однотипных элементов, а кортеж из двух массивов - горизонтального и вертикального типов совпадения;
- новая функция получает этот кортеж и объединяет вертикальные совпадения с горизонтальными по признаку наличия общего элемента;
- в итоге она возвращает единый список совпадений, среди которых есть и линейные, и Г-тип, и Т-тип;
- remove_matches, которая, помимо прочего, занимается ещё и подсчётом очков, сначала подсчитывает количество элементов к удалению (общие элементы поучаствуют 2 или даже 3 раза - вот и первый бонус), потом передаёт совпадения в новую функцию объединения совпадений, потом вызывает функцию создания особенных элементов из особо больших совпадений, потом вызывает гравитацию, т.е. мы возвращаемся к исходному коду;
- все изменения в исходном коде - это создание двух новых функций: объединение совпадений и создание уникальных элементов-бонусов - и вставка вызова этих функций в конвейер.
Да, remove_matches надо переписать на конвейер, так будет более наглядно.